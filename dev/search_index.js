var documenterSearchIndex = {"docs":
[{"location":"guide/#guide","page":"Usage Guide","title":"Usage Guide","text":"Intervals in SortedIntervals are plain (start, stop) tuples. Most functions that operate on collections of intervals assume the collection is sorted by start time. Functions that require non-overlapping input will validate this and throw an error if violated.","category":"section"},{"location":"guide/#Overlap-Detection","page":"Usage Guide","title":"Overlap Detection","text":"Test whether intervals overlap, or find overlapping pairs within a collection.\n\ncheck_overlap tests whether two intervals share any points (closed-interval semantics, so touching endpoints count as overlapping):\n\ncheck_overlap((1, 5), (3, 8))   # true\ncheck_overlap((1, 5), (5, 8))   # true  (touching)\ncheck_overlap((1, 5), (6, 8))   # false\n\nIt also works on a vector, checking all pairs:\n\ncheck_overlap([(1, 3), (2, 5), (7, 9)])  # true — (1,3) and (2,5) overlap\n\nis_subinterval tests containment:\n\nis_subinterval((2, 4), (1, 5))  # true — (2,4) is inside (1,5)\nis_subinterval((2, 6), (1, 5))  # false\n\nfind_overlaps returns, for each interval, the indices of all other intervals it overlaps with. Assumes sorted input so it can stop early:\n\nfind_overlaps([(1, 5), (3, 7), (10, 12)])\n# [[2], [1], []] — interval 1 overlaps interval 2 and vice versa\n\nfind_all_overlapping takes two sorted, non-overlapping interval lists and returns a BitVector marking which intervals in the first list overlap with any interval in the second:\n\nfind_all_overlapping([(1, 3), (5, 7), (10, 12)], [(2, 6)])\n# BitVector([1, 1, 0])","category":"section"},{"location":"guide/#Intersections","page":"Usage Guide","title":"Intersections","text":"Compute the overlapping region between intervals.\n\ninterval_intersect returns the intersection of two intervals, or nothing if they don't overlap:\n\ninterval_intersect((1, 5), (3, 8))  # (3, 5)\ninterval_intersect((1, 2), (3, 4))  # nothing\n\ninterval_intersect_measure returns just the length of the overlap:\n\ninterval_intersect_measure((0, 10), (5, 15))  # 5\ninterval_intersect_measure((1, 2), (3, 4))    # 0\n\ninterval_intersections computes all pairwise intersections between two sorted, non-overlapping lists:\n\ninterval_intersections([(1, 5), (7, 10)], [(3, 8)])\n# [(3, 5), (7, 8)]\n\ninterval_intersections_overlapping does the same but allows the input lists to contain overlapping intervals (they must still be sorted by start time). Overlapping results are merged:\n\ninterval_intersections_overlapping([(1, 5), (3, 7)], [(2, 10)])\n# [(2, 7)]","category":"section"},{"location":"guide/#Set-Operations","page":"Usage Guide","title":"Set Operations","text":"intervals_diff computes the set difference — the portions of the first list not covered by the second:\n\nintervals_diff([(1, 10)], [(3, 5), (7, 8)])\n# [(1, 3), (5, 7), (8, 10)]\n\ninterval_complements finds the gaps between intervals within a bounding range. An optional contraction parameter shrinks each gap boundary inward:\n\ninterval_complements(0, 10, [(2, 4), (6, 8)])\n# [(0, 2), (4, 6), (8, 10)]\n\ninterval_complements(0.0, 10.0, [(4.0, 6.0)], 1.0)\n# [(1.0, 3.0), (7.0, 9.0)]\n\noverlap_interval_union returns the bounding interval that covers both inputs:\n\noverlap_interval_union((1, 5), (3, 8))  # (1, 8)","category":"section"},{"location":"guide/#Merging-and-Expansion","page":"Usage Guide","title":"Merging and Expansion","text":"join_intervals merges successive intervals when the gap between them is at most min_gap:\n\njoin_intervals([(1, 3), (4, 6), (10, 12)], 1)\n# [(1, 6), (10, 12)]\n\njoin_intervals! does the same in-place, resizing the input vector.\n\nexpand_intervals widens each interval by expand / 2 on each side, then merges any resulting overlaps:\n\nexpand_intervals([(2, 4), (8, 10)], 2)\n# [(1, 5), (7, 11)]\n\nexpand_intervals! does the same in-place.\n\nthrottle converts a sorted vector of points into intervals by grouping consecutive points that are within min_gap of each other:\n\nthrottle([1, 2, 3, 10, 11, 20], 2)\n# [(1, 3), (10, 11), (20, 20)]","category":"section"},{"location":"guide/#Validation","page":"Usage Guide","title":"Validation","text":"intervals_are_ordered checks that intervals are well-formed (start <= stop), sorted by start time, and non-overlapping:\n\nintervals_are_ordered([(1, 3), (4, 6)])  # true\nintervals_are_ordered([(1, 5), (3, 7)])  # false — overlapping\nintervals_are_ordered([(5, 1)])          # false — malformed\n\nintervals_are_partially_ordered is the same but allows overlaps:\n\nintervals_are_partially_ordered([(1, 5), (3, 7)])  # true\n\nBoth accept an accessor function for working with non-tuple collections:\n\nintervals_are_ordered(x -> x.time, my_data)","category":"section"},{"location":"guide/#Utilities","page":"Usage Guide","title":"Utilities","text":"measure and midpoint compute basic interval properties:\n\nmeasure((3, 7))   # 4\nmidpoint((2, 6))  # 4.0\nmeasure(nothing)  # 0 — useful after interval_intersect\n\nclip_int clamps an interval to lie within bounds (each endpoint clamped independently):\n\nclip_int((1, 10), (3, 8))  # (3, 8)\n\nclip_interval_duration clips an interval to bounds while attempting to preserve its duration by shifting:\n\nclip_interval_duration(8, 12, 0, 10)  # (6, 10) — shifted left to fit\nclip_interval_duration(-2, 5, 0, 10)  # (0, 7)  — shifted right to fit\n\ninterval_indices finds the index range in a sorted vector that falls within an interval, using binary search:\n\ninterval_indices([10, 20, 30, 40, 50], 15, 35)  # (2, 3)\n\nmask_events returns a view of a sorted vector containing only elements within a range:\n\nmask_events([1, 3, 5, 7, 9], 2, 6)  # [3, 5]\n\nmaximum_interval_overlap finds which interval in a collection has the greatest overlap with a target:\n\nmaximum_interval_overlap([(1, 5), (4, 10), (12, 15)], (3, 8))\n# (2, 4) — index 2, overlap of 4\n\nmeasure_to_bounds converts (start, duration) to (start, stop):\n\nmeasure_to_bounds(5, 3)  # (5, 8)\n\nreduce_extrema and extrema_red compute bounding ranges:\n\nreduce_extrema((1, 5), (3, 8))              # (1, 8)\nextrema_red([(1, 5), (3, 8), (6, 7)])       # (1, 8)\n\nparse_ranges_str parses human-readable range strings:\n\nparse_ranges_str(\"1-3, 7, 10-12\")  # [1, 2, 3, 7, 10, 11, 12]\n\nclipsize! resizes a vector and releases excess memory capacity:\n\nv = Vector{Int}(undef, 100)\nclipsize!(v, 3)  # now length 3 with no excess allocation","category":"section"},{"location":"api/#api","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#SortedIntervals.check_overlap-NTuple{4, Any}","page":"API Reference","title":"SortedIntervals.check_overlap","text":"check_overlap(start1, stop1, start2, stop2) -> Bool\ncheck_overlap(a::NTuple{2,<:Number}, b::NTuple{2,<:Number}) -> Bool\ncheck_overlap(intervals::AbstractVector{<:NTuple{2}}) -> Bool\n\nTest whether two intervals overlap, or whether any pair of intervals in a vector overlaps.\n\nIntervals are treated as closed (endpoints are included).\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.clip_int-NTuple{4, Number}","page":"API Reference","title":"SortedIntervals.clip_int","text":"clip_int(int_begin, int_end, bound_begin, bound_end) -> NTuple{2}\nclip_int(input::NTuple{2,<:Number}, bounds::NTuple{2,<:Number}) -> NTuple{2}\n\nClamp an interval to lie within the given bounds. Each endpoint is clamped independently.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.clip_interval_duration-Union{Tuple{T}, NTuple{4, T}} where T<:Number","page":"API Reference","title":"SortedIntervals.clip_interval_duration","text":"clip_interval_duration(reqb, reqe, boundmin, boundmax) -> NTuple{2}\nclip_interval_duration(int::NTuple{2}, bounds::NTuple{2}) -> NTuple{2}\n\nClip an interval to lie within [boundmin, boundmax] while attempting to preserve its duration. The interval is shifted to fit within the bounds when possible. If the requested interval is longer than the bounds, it is clamped to exactly [boundmin, boundmax].\n\nExamples\n\njulia> clip_interval_duration(8, 12, 0, 10)\n(6, 10)\n\njulia> clip_interval_duration(-2, 5, 0, 10)\n(0, 7)\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.clipsize!-Tuple{AbstractVector, Integer}","page":"API Reference","title":"SortedIntervals.clipsize!","text":"clipsize!(a::AbstractVector, n::Integer) -> AbstractVector\n\nResize a to length n and release excess memory capacity.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.expand_intervals!-Tuple{AbstractVector{<:Tuple{var\"#s7\", var\"#s7\"} where var\"#s7\"<:Number}, Number}","page":"API Reference","title":"SortedIntervals.expand_intervals!","text":"expand_intervals!(ints_in::AbstractVector{<:NTuple{2,<:Number}}, expand::Number) -> AbstractVector\n\nExpand each interval by expand / 2 on each side, then merge any resulting overlaps. Mutates and resizes ints_in in-place.\n\nSee expand_intervals for a non-mutating version.\n\nExamples\n\njulia> ints = [(2, 4), (8, 10)];\n\njulia> expand_intervals!(ints, 2)\n2-element Vector{Tuple{Int64, Int64}}:\n (1, 5)\n (7, 11)\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.expand_intervals-Tuple{Any, Any}","page":"API Reference","title":"SortedIntervals.expand_intervals","text":"expand_intervals(ints_in, expand::Number) -> Vector\n\nNon-mutating version of expand_intervals!.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.extrema_red-Tuple{AbstractVector{<:Number}}","page":"API Reference","title":"SortedIntervals.extrema_red","text":"extrema_red(a::AbstractVector{<:Number}) -> NTuple{2}\nextrema_red(a::AbstractArray{<:Number, 2}) -> NTuple{2}\nextrema_red(a::AbstractVector{<:NTuple{2,Number}}) -> NTuple{2}\n\nReturn the overall (minimum, maximum) across a collection of intervals or numbers.\n\nFor a vector of numbers, equivalent to extrema. For a 2×N matrix, treats each column as an interval. For a vector of 2-tuples, finds the global minimum start and maximum stop.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.find_all_overlapping-NTuple{4, Any}","page":"API Reference","title":"SortedIntervals.find_all_overlapping","text":"find_all_overlapping(intsa, intsb) -> BitVector\nfind_all_overlapping(fa, fb, intsa, intsb) -> BitVector\n\nReturn a BitVector of length length(intsa) indicating which intervals in intsa overlap with any interval in intsb. Optional accessor functions fa and fb extract (start, stop) tuples from each element.\n\nBoth inputs must be sorted and non-overlapping (see intervals_are_ordered).\n\nExamples\n\njulia> find_all_overlapping([(1, 3), (5, 7), (10, 12)], [(2, 6)])\n3-element BitVector:\n 1\n 1\n 0\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.find_overlaps-Tuple{AbstractVector{<:Tuple{var\"#s11\", var\"#s12\"} where {var\"#s11\", var\"#s12\"}}}","page":"API Reference","title":"SortedIntervals.find_overlaps","text":"find_overlaps(intervals::AbstractVector{<:Tuple{<:Any,<:Any}}) -> Vector{Vector{Int}}\n\nFind all pairwise overlaps in a vector of intervals. Returns a vector of index lists, where result[i] contains the indices of all intervals that overlap with interval i.\n\nAssumes intervals is sorted by start time.\n\nExamples\n\njulia> find_overlaps([(1, 5), (3, 7), (8, 10)])\n3-element Vector{Vector{Int64}}:\n [2]\n [1]\n []\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.interval_complements-Union{Tuple{T}, Tuple{T, T, AbstractVector{<:Tuple{T, T}}}, Tuple{T, T, AbstractVector{<:Tuple{T, T}}, Number}} where T","page":"API Reference","title":"SortedIntervals.interval_complements","text":"interval_complements(start, stop, intervals, contraction=0) -> Vector{NTuple{2}}\n\nFind the gaps between intervals within the bounding interval [start, stop]. Each complement boundary is contracted inward by contraction (useful for excluding edge artifacts).\n\nAssumes intervals is sorted and non-overlapping.\n\nExamples\n\njulia> interval_complements(0, 10, [(2, 4), (6, 8)])\n3-element Vector{Tuple{Int64, Int64}}:\n (0, 2)\n (4, 6)\n (8, 10)\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.interval_indices-Tuple{AbstractVector, Number, Number}","page":"API Reference","title":"SortedIntervals.interval_indices","text":"interval_indices(basis, start::Number, stop::Number) -> (i_b, i_e)\ninterval_indices(basis, bounds::NTuple{2,<:Number}) -> (i_b, i_e)\n\nFind the first and last indices in the sorted collection basis whose values fall within [start, stop]. Uses binary search (searchsortedfirst / searchsortedlast).\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.interval_intersect-Union{Tuple{T}, NTuple{4, T}} where T","page":"API Reference","title":"SortedIntervals.interval_intersect","text":"interval_intersect(start1, stop1, start2, stop2) -> NTuple{2} | Nothing\ninterval_intersect(a::NTuple{2}, b::NTuple{2}) -> NTuple{2} | Nothing\n\nReturn the intersection of two intervals, or nothing if they do not overlap.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.interval_intersect_measure-Union{Tuple{T}, NTuple{4, T}} where T","page":"API Reference","title":"SortedIntervals.interval_intersect_measure","text":"interval_intersect_measure(start1, stop1, start2, stop2) -> Number\ninterval_intersect_measure(a::NTuple{2}, b::NTuple{2}) -> Number\n\nReturn the length of the intersection of two intervals, or zero if they do not overlap.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.interval_intersections-Tuple{Any, Any}","page":"API Reference","title":"SortedIntervals.interval_intersections","text":"interval_intersections(intsa, intsb) -> Vector{NTuple{2}}\n\nCompute all pairwise intersections between two collections of intervals. Both inputs must be sorted and non-overlapping (see intervals_are_ordered). Returns a sorted, non-overlapping vector of intersection intervals.\n\nSee also interval_intersections_overlapping for inputs that may contain overlaps.\n\nExamples\n\njulia> interval_intersections([(1, 5), (7, 10)], [(3, 8)])\n2-element Vector{Tuple{Int64, Int64}}:\n (3, 5)\n (7, 8)\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.interval_intersections_overlapping-Tuple{Any, Any}","page":"API Reference","title":"SortedIntervals.interval_intersections_overlapping","text":"interval_intersections_overlapping(intsa, intsb) -> Vector{NTuple{2}}\n\nLike interval_intersections, but allows the input interval lists to contain overlapping intervals. Both inputs must still be sorted by start time (see intervals_are_partially_ordered). Overlapping results are merged.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.intervals_are_ordered-Tuple{Any, Any}","page":"API Reference","title":"SortedIntervals.intervals_are_ordered","text":"intervals_are_ordered(ints) -> Bool\nintervals_are_ordered(f, ints) -> Bool\n\nCheck that each interval is well-formed (start <= stop), intervals are sorted by start time, and no intervals overlap. An optional accessor function f extracts (start, stop) from each element.\n\nSee also intervals_are_partially_ordered.\n\nExamples\n\njulia> intervals_are_ordered([(1, 3), (4, 6), (7, 9)])\ntrue\n\njulia> intervals_are_ordered([(1, 5), (3, 7)])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.intervals_are_partially_ordered-Tuple{Any, Any}","page":"API Reference","title":"SortedIntervals.intervals_are_partially_ordered","text":"intervals_are_partially_ordered(ints) -> Bool\nintervals_are_partially_ordered(f, ints) -> Bool\n\nCheck that each interval is well-formed and intervals are sorted by start time. Unlike intervals_are_ordered, overlapping intervals are permitted.\n\nExamples\n\njulia> intervals_are_partially_ordered([(1, 5), (3, 7)])\ntrue\n\njulia> intervals_are_partially_ordered([(3, 7), (1, 5)])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.intervals_diff-Union{Tuple{T}, Tuple{S}, Tuple{AbstractVector{<:Tuple{S, S}}, AbstractVector{<:Tuple{T, T}}}} where {S<:Number, T<:Number}","page":"API Reference","title":"SortedIntervals.intervals_diff","text":"intervals_diff(ints_a, ints_b) -> Vector{NTuple{2}}\n\nCompute the set difference of two sorted interval collections: the portions of ints_a that are not covered by any interval in ints_b. Both inputs must be sorted and non-overlapping.\n\nExamples\n\njulia> intervals_diff([(1, 10)], [(3, 5), (7, 8)])\n3-element Vector{Tuple{Int64, Int64}}:\n (1, 3)\n (5, 7)\n (8, 10)\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.is_subinterval-NTuple{4, Any}","page":"API Reference","title":"SortedIntervals.is_subinterval","text":"is_subinterval(startchild, stopchild, startparent, stopparent) -> Bool\nis_subinterval(child::NTuple{2,<:Number}, parent::NTuple{2,<:Number}) -> Bool\n\nTest whether the child interval is entirely contained within the parent interval.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.join_intervals!","page":"API Reference","title":"SortedIntervals.join_intervals!","text":"join_intervals!(ints::AbstractVector{<:NTuple{2,<:Number}}, min_gap=0) -> AbstractVector\njoin_intervals!(f, ints::AbstractVector{<:NTuple{2,<:Number}}, min_gap=0) -> AbstractVector\n\nMerge successive intervals in the sorted vector ints when the gap between them is at most min_gap. Mutates and resizes ints in-place. An optional function f is applied to each merged interval before storing.\n\nAssumes ints is sorted by start time. See join_intervals for a non-mutating version.\n\nExamples\n\njulia> ints = [(1, 3), (4, 6), (10, 12)];\n\njulia> join_intervals!(ints, 1)\n2-element Vector{Tuple{Int64, Int64}}:\n (1, 6)\n (10, 12)\n\n\n\n\n\n","category":"function"},{"location":"api/#SortedIntervals.join_intervals-Tuple{Any, AbstractVector, Vararg{Any}}","page":"API Reference","title":"SortedIntervals.join_intervals","text":"join_intervals(ints::AbstractVector{<:NTuple{2,<:Number}}, min_gap=0) -> Vector\njoin_intervals(f, ints::AbstractVector{<:NTuple{2,<:Number}}, min_gap=0) -> Vector\n\nNon-mutating version of join_intervals!. Returns a new vector with successive intervals merged when the gap between them is at most min_gap.\n\nExamples\n\njulia> join_intervals([(1, 3), (4, 6), (10, 12)], 1)\n2-element Vector{Tuple{Int64, Int64}}:\n (1, 6)\n (10, 12)\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.mask_events-Tuple{AbstractVector{<:Number}, Any, Any}","page":"API Reference","title":"SortedIntervals.mask_events","text":"mask_events(event_times::AbstractVector{<:Number}, start, stop) -> SubArray\n\nReturn a view of event_times containing only elements within [start, stop]. Uses binary search via interval_indices. Assumes event_times is sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.maximum_interval_overlap-Union{Tuple{T}, Tuple{AbstractArray{Tuple{T, T}, 1}, Tuple{T, T}}} where T","page":"API Reference","title":"SortedIntervals.maximum_interval_overlap","text":"maximum_interval_overlap(xs::AbstractVector{NTuple{2,T}}, y::NTuple{2,T}) -> (index, overlap)\n\nFind the interval in xs that has the greatest overlap with the target interval y. Returns the index of the best-matching interval and the overlap measure. Returns (0, typemin(T)) if xs is empty.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.measure-Tuple{Tuple{var\"#s11\", var\"#s11\"} where var\"#s11\"<:Number}","page":"API Reference","title":"SortedIntervals.measure","text":"measure(a::NTuple{2,<:Number}) -> Number\nmeasure(::Nothing) -> Int\n\nReturn the length (duration) of an interval a, i.e. a[2] - a[1]. Returns 0 for nothing, which is useful when chained with interval_intersect.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.measure_to_bounds-Tuple{Number, Number}","page":"API Reference","title":"SortedIntervals.measure_to_bounds","text":"measure_to_bounds(start::Number, duration::Number) -> NTuple{2}\nmeasure_to_bounds(t::NTuple{2}) -> NTuple{2}\nmeasure_to_bounds(ts::AbstractArray{<:NTuple{2}}) -> AbstractArray\nmeasure_to_bounds(starts::AbstractArray, durations::AbstractArray) -> AbstractArray\n\nConvert a (start, duration) representation to a (start, stop) representation, where stop = start + duration.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.midpoint-Tuple{Tuple{var\"#s11\", var\"#s11\"} where var\"#s11\"<:Number}","page":"API Reference","title":"SortedIntervals.midpoint","text":"midpoint(a::NTuple{2,<:Number}) -> Number\n\nReturn the midpoint of an interval a.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.overlap_interval_union-NTuple{4, Any}","page":"API Reference","title":"SortedIntervals.overlap_interval_union","text":"overlap_interval_union(a::NTuple{2}, b::NTuple{2}) -> NTuple{2}\noverlap_interval_union(ab, ae, bb, be) -> NTuple{2}\n\nReturn the bounding interval that covers both a and b. The inputs are assumed to overlap; if they don't, the result spans the gap between them.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.parse_ranges_str-Tuple{AbstractString}","page":"API Reference","title":"SortedIntervals.parse_ranges_str","text":"parse_ranges_str(s::AbstractString) -> Vector{Int}\n\nParse a comma-separated string of integers and integer ranges into a sorted vector of unique integers. Ranges are specified with hyphens.\n\nExamples\n\njulia> parse_ranges_str(\"1-3, 7, 10-12\")\n7-element Vector{Int64}:\n  1\n  2\n  3\n  7\n 10\n 11\n 12\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.reduce_extrema-Union{Tuple{T}, NTuple{4, T}} where T<:Number","page":"API Reference","title":"SortedIntervals.reduce_extrema","text":"reduce_extrema(a::NTuple{2,T}, b::NTuple{2,T}) -> NTuple{2,T}\nreduce_extrema(s1, s2, t1, t2) -> NTuple{2}\n\nReturn (min(a[1], b[1]), max(a[2], b[2])) — the bounding interval that contains both input intervals. Useful as a reduction operator over a collection of intervals.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.throttle-Union{Tuple{T}, Tuple{AbstractVector{T}, Number}} where T<:Number","page":"API Reference","title":"SortedIntervals.throttle","text":"throttle(xs::AbstractVector{T}, min_gap::Number) -> Vector{NTuple{2,T}} where T<:Number\n\nGroup sorted points into intervals by merging consecutive points that are within min_gap of each other. Each output interval spans from the first to last point in its group.\n\nAssumes xs is sorted.\n\nExamples\n\njulia> throttle([1, 2, 3, 10, 11, 20], 2)\n3-element Vector{Tuple{Int64, Int64}}:\n (1, 3)\n (10, 11)\n (20, 20)\n\n\n\n\n\n","category":"method"},{"location":"#SortedIntervals.jl","page":"Home","title":"SortedIntervals.jl","text":"SortedIntervals provides fast set operations on sorted, non-overlapping intervals represented as plain NTuple{2} tuples. By assuming intervals are sorted by start time, most operations run in O(n) time using linear scans rather than O(n^2) pairwise comparisons.","category":"section"},{"location":"#Design-Principles","page":"Home","title":"Design Principles","text":"Tuples, not types. Intervals are (start, stop) tuples. There is no Interval struct. This means zero overhead, easy interop with existing code, and no need to convert between representations.\n\nSorted-input assumption. Functions that operate on collections of intervals assume they are sorted by start time. This is what makes O(n) algorithms possible. Use intervals_are_ordered to validate, or intervals_are_partially_ordered if overlaps are expected.\n\nIn-place variants. Functions that resize their output (like join_intervals! and expand_intervals!) have mutating versions that modify arrays in-place to reduce allocations. Non-mutating versions copy first.\n\nAccessor functions. Many functions accept an optional function f that extracts (start, stop) from each element, so you can operate on collections of structs or named tuples without converting them first:\n\n# Works on any collection, as long as f returns (start, stop)\nintervals_are_ordered(x -> x.time_range, my_trials)","category":"section"},{"location":"#Example-Workflow","page":"Home","title":"Example Workflow","text":"A typical workflow for temporal data analysis (e.g., neuroscience trial data):\n\nusing SortedIntervals\n\n# Define trial windows and artifact periods\ntrials = [(0.0, 5.0), (10.0, 15.0), (20.0, 25.0)]\nartifacts = [(3.0, 12.0), (22.0, 23.0)]\n\n# Validate inputs\nintervals_are_ordered(trials)     # true\nintervals_are_ordered(artifacts)  # true\n\n# Remove artifact periods from trials\nclean = intervals_diff(trials, artifacts)\n# [(0.0, 3.0), (12.0, 15.0), (20.0, 22.0), (23.0, 25.0)]\n\n# Merge fragments separated by small gaps\njoined = join_intervals(clean, 1.5)\n# [(0.0, 3.0), (10.0, 15.0), (20.0, 25.0)]\n\n# Find gaps in the clean data within a recording window\ngaps = interval_complements(0.0, 30.0, joined)\n\n# Select events that fall within clean periods\nevent_times = [1.0, 4.0, 11.0, 21.0, 28.0]\nevents_in_first = mask_events(event_times, joined[1]...)\n\nSee the Usage Guide for detailed examples of each function category, or the API Reference for complete function signatures.","category":"section"}]
}
